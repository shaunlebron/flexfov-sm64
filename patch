From f0ed85a07ef84950ee4a3558833964b9850f1249 Mon Sep 17 00:00:00 2001
From: Shaun Williams <shaunewilliams@gmail.com>
Date: Sun, 19 Jul 2020 03:16:05 -0500
Subject: [PATCH] squashed flexfov work

---
 Makefile                          |   2 +
 src/game/area.c                   |   9 +-
 src/game/camera.c                 |   5 +
 src/game/game_init.h              |   2 +-
 src/game/rendering_graph_node.c   |  17 +-
 src/pc/gfx/gfx_opengl.c           |   2 +-
 src/pc/gfx/gfx_pc.c               |  23 +-
 src/pc/gfx/gfx_sdl2.c             |   3 +

diff --git a/Makefile b/Makefile
index 4f42f74..08ef5c9 100644
--- a/Makefile
+++ b/Makefile
@@ -858,6 +858,8 @@ $(EXE): $(O_FILES) $(MIO0_FILES:.mio0=.o) $(SOUND_OBJ_FILES) $(ULTRA_O_FILES) $(
 endif
 
 
+src/game/flexfov_shaders.c: quad.vert quad.frag quad.sh
+	./quad.sh
 
 .PHONY: all clean distclean default diff test load libultra
 # with no prerequisites, .SECONDARY causes no intermediate target to be removed
diff --git a/src/game/area.c b/src/game/area.c
index d458bf7..4a6ea9e 100644
--- a/src/game/area.c
+++ b/src/game/area.c
@@ -21,6 +21,7 @@
 #include "engine/geo_layout.h"
 #include "save_file.h"
 #include "level_table.h"
+#include "flexfov.h"
 
 struct SpawnInfo gPlayerSpawnInfos[1];
 struct GraphNode *D_8033A160[0x100];
@@ -363,7 +366,11 @@ void play_transition_after_delay(s16 transType, s16 time, u8 red, u8 green, u8 b
 
 void render_game(void) {
     if (gCurrentArea != NULL && !gWarpTransition.pauseRendering) {
-        geo_process_root(gCurrentArea->unk04, D_8032CE74, D_8032CE78, gFBSetColor);
+        if (flexfov_is_on()) {
+          flexfov_render_world(gCurrentArea->unk04, D_8032CE74, D_8032CE78, gFBSetColor);
+        } else {
+          geo_process_root(gCurrentArea->unk04, D_8032CE74, D_8032CE78, gFBSetColor);
+        }
 
         gSPViewport(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&D_8032CF00));
 
diff --git a/src/game/camera.c b/src/game/camera.c
index 60bfb86..6236672 100644
--- a/src/game/camera.c
+++ b/src/game/camera.c
@@ -28,6 +28,7 @@
 #include "paintings.h"
 #include "engine/graph_node.h"
 #include "level_table.h"
+#include "flexfov.h"
 
 #define CBUTTON_MASK (U_CBUTTONS | D_CBUTTONS | L_CBUTTONS | R_CBUTTONS)
 
@@ -11444,6 +11445,10 @@ Gfx *geo_camera_fov(s32 callContext, struct GraphNode *g, UNUSED void *context)
     }
 
     perspective->fov = sFOVState.fov;
+
+    if (flexfov_is_on()) {
+      perspective->fov = 90.0f;
+    }
     shake_camera_fov(perspective);
     return NULL;
 }
diff --git a/src/game/game_init.h b/src/game/game_init.h
index 4384cbc..bf5d216 100644
--- a/src/game/game_init.h
+++ b/src/game/game_init.h
@@ -9,7 +9,7 @@
 #include "types.h"
 #include "memory.h"
 
-#define GFX_POOL_SIZE 6400
+#define GFX_POOL_SIZE (6400*6)
 
 struct GfxPool {
     Gfx buffer[GFX_POOL_SIZE];
diff --git a/src/game/rendering_graph_node.c b/src/game/rendering_graph_node.c
index a421271..3132bd7 100644
--- a/src/game/rendering_graph_node.c
+++ b/src/game/rendering_graph_node.c
@@ -10,6 +10,7 @@
 #include "rendering_graph_node.h"
 #include "shadow.h"
 #include "sm64.h"
+#include "flexfov.h"
 
 /**
  * This file contains the code that processes the scene graph for rendering.
@@ -236,6 +237,7 @@ static void geo_process_ortho_projection(struct GraphNodeOrthoProjection *node)
  * Process a perspective projection node.
  */
 static void geo_process_perspective(struct GraphNodePerspective *node) {
+    if (flexfov_is_on() && flexFovSky) return;
     if (node->fnNode.func != NULL) {
         node->fnNode.func(GEO_CONTEXT_RENDER, &node->fnNode.node, gMatStack[gMatStackIndex]);
     }
@@ -316,6 +318,11 @@ static void geo_process_camera(struct GraphNodeCamera *node) {
 
     mtxf_lookat(cameraTransform, node->pos, node->focus, node->roll);
     mtxf_mul(gMatStack[gMatStackIndex + 1], cameraTransform, gMatStack[gMatStackIndex]);
+ 
+    if (flexfov_is_on()) {
+      flexfov_set_cam(gMatStack[gMatStackIndex + 1]);
+    }
+
     gMatStackIndex++;
     mtxf_to_mtx(mtx, gMatStack[gMatStackIndex]);
     gMatStackFixed[gMatStackIndex] = mtx;
@@ -438,8 +445,9 @@ static void geo_process_billboard(struct GraphNodeBillboard *node) {
 
     gMatStackIndex++;
     vec3s_to_vec3f(translation, node->translation);
+
     mtxf_billboard(gMatStack[gMatStackIndex], gMatStack[gMatStackIndex - 1], translation,
-                   gCurGraphNodeCamera->roll);
+                   flexfov_is_on() ? flexFovRoll : gCurGraphNodeCamera->roll);
     if (gCurGraphNodeHeldObject != NULL) {
         mtxf_scale_vec3f(gMatStack[gMatStackIndex], gMatStack[gMatStackIndex],
                          gCurGraphNodeHeldObject->objNode->header.gfx.scale);
@@ -497,6 +505,7 @@ static void geo_process_generated_list(struct GraphNodeGenerated *node) {
  * rectangle is drawn instead.
  */
 static void geo_process_background(struct GraphNodeBackground *node) {
+    if (flexfov_is_on() && !flexFovSky) return;
     Gfx *list = NULL;
 
     if (node->fnNode.func != NULL) {
@@ -744,6 +753,9 @@ static int obj_is_in_view(struct GraphNodeObject *node, Mat4 matrix) {
     if (node->node.flags & GRAPH_RENDER_INVISIBLE) {
         return FALSE;
     }
+    if (flexfov_is_on()) {
+      return TRUE;
+    }
 
     geo = node->sharedChild;
 
@@ -806,7 +818,8 @@ static void geo_process_object(struct Object *node) {
                      gMatStack[gMatStackIndex]);
         } else if (node->header.gfx.node.flags & GRAPH_RENDER_BILLBOARD) {
             mtxf_billboard(gMatStack[gMatStackIndex + 1], gMatStack[gMatStackIndex],
-                           node->header.gfx.pos, gCurGraphNodeCamera->roll);
+                           node->header.gfx.pos,
+                           flexfov_is_on() ? flexFovRoll : gCurGraphNodeCamera->roll);
         } else {
             mtxf_rotate_zxy_and_translate(mtxf, node->header.gfx.pos, node->header.gfx.angle);
             mtxf_mul(gMatStack[gMatStackIndex + 1], mtxf, gMatStack[gMatStackIndex]);
diff --git a/src/pc/gfx/gfx_opengl.c b/src/pc/gfx/gfx_opengl.c
index 953ccc4..d60058d 100644
--- a/src/pc/gfx/gfx_opengl.c
+++ b/src/pc/gfx/gfx_opengl.c
@@ -16,7 +16,7 @@
 
 #if FOR_WINDOWS || defined(TARGET_OSX)
 #define GLEW_STATIC
-#include <GL/glew.h>
+#include <OpenGL/gl3.h>
 #endif
 
 #include <SDL2/SDL.h>
diff --git a/src/pc/gfx/gfx_pc.c b/src/pc/gfx/gfx_pc.c
index a60299e..ccb486c 100644
--- a/src/pc/gfx/gfx_pc.c
+++ b/src/pc/gfx/gfx_pc.c
@@ -4,6 +4,7 @@
 #include <string.h>
 #include <stdbool.h>
 #include <assert.h>
+#include "src/game/flexfov.h"
 
 #ifndef _LANGUAGE_C
 #define _LANGUAGE_C
@@ -160,7 +161,7 @@ static unsigned long get_time(void) {
     return (unsigned long)ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
 }
 
-static void gfx_flush(void) {
+void gfx_flush(void) {
     if (buf_vbo_len > 0) {
         int num = buf_vbo_num_tris;
         unsigned long t0 = get_time();
@@ -174,6 +175,11 @@ static void gfx_flush(void) {
     }
 }
 
+void gfx_unload_current_shader(void) {
+    gfx_rapi->unload_shader(rendering_state.shader_program);
+    rendering_state.shader_program = NULL; // <-- needed? (so state isnâ€™t desynced with opengl)
+}
+
 static struct ShaderProgram *gfx_lookup_or_create_shader_program(uint32_t shader_id) {
     struct ShaderProgram *prg = gfx_rapi->lookup_shader(shader_id);
     if (prg == NULL) {
@@ -621,7 +627,13 @@ static void gfx_sp_vertex(size_t n_vertices, size_t dest_index, const Vtx *verti
         if (rsp.geometry_mode & G_LIGHTING) {
             if (rsp.lights_changed) {
                 for (int i = 0; i < rsp.current_num_lights - 1; i++) {
-                    calculate_normal_dir(&rsp.current_lights[i], rsp.current_lights_coeffs[i]);
+                    if (flexfov_is_on()) {
+                        Light_t light = rsp.current_lights[i];
+                        flexfov_set_light_direction(&light);
+                        calculate_normal_dir(&light, rsp.current_lights_coeffs[i]);
+                    } else {
+                        calculate_normal_dir(&rsp.current_lights[i], rsp.current_lights_coeffs[i]);
+                    }
                 }
                 static const Light_t lookat_x = {{0, 0, 0}, 0, {0, 0, 0}, 0, {127, 0, 0}, 0};
                 static const Light_t lookat_y = {{0, 0, 0}, 0, {0, 0, 0}, 0, {0, 127, 0}, 0};
@@ -945,7 +957,7 @@ static void gfx_calc_and_set_viewport(const Vp_t *viewport) {
     rdp.viewport.y = y;
     rdp.viewport.width = width;
     rdp.viewport.height = height;
-    
+
     rdp.viewport_or_scissor_changed = true;
 }
 
@@ -1360,6 +1372,9 @@ static void gfx_run_dl(Gfx* cmd) {
     int dummy = 0;
     for (;;) {
         uint32_t opcode = cmd->words.w0 >> 24;
+        if (flexfov_is_on()) {
+          flexfov_run_prehook(cmd);
+        }
         
         switch (opcode) {
             // RSP commands:
@@ -1610,6 +1625,8 @@ void gfx_init(struct GfxWindowManagerAPI *wapi, struct GfxRenderingAPI *rapi, co
     for (size_t i = 0; i < sizeof(precomp_shaders) / sizeof(uint32_t); i++) {
         gfx_lookup_or_create_shader_program(precomp_shaders[i]);
     }
+
+    flexfov_gfx_init();
 }
 
 struct GfxRenderingAPI *gfx_get_current_rendering_api(void) {
diff --git a/src/pc/gfx/gfx_sdl2.c b/src/pc/gfx/gfx_sdl2.c
index 55d143e..4f9d791 100644
--- a/src/pc/gfx/gfx_sdl2.c
+++ b/src/pc/gfx/gfx_sdl2.c
@@ -24,6 +24,8 @@
 #include "gfx_window_manager_api.h"
 #include "gfx_screen_config.h"
 
+#include "src/game/flexfov.h"
+
 #define GFX_API_NAME "SDL2 - OpenGL"
 
 static SDL_Window *wnd;
@@ -262,6 +264,7 @@ static void gfx_sdl_handle_events(void) {
                 if (event.window.event == SDL_WINDOWEVENT_SIZE_CHANGED) {
                     window_width = event.window.data1;
                     window_height = event.window.data2;
+                    flexfov_resize_cubemap();
                 }
                 break;
             case SDL_QUIT:
-- 
2.17.1

